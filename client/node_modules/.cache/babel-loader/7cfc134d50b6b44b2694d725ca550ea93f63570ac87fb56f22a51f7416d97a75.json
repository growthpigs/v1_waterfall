{"ast":null,"code":"var _jsxFileName = \"/Users/rodericandrews/Factory-ai/waterfall-app/client/src/components/CIA/CIAWizard.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from \"react\";\nimport axios from \"../../utils/axios\";\n// Import other dependencies\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CIAWizard = () => {\n  _s();\n  // State declarations\n  const [formData, setFormData] = useState({\n    companyName: \"\",\n    websiteUrl: \"\",\n    keyPersonOfInfluence: \"\",\n    primaryKeyword: \"\"\n  });\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSubmitted, setIsSubmitted] = useState(false);\n  const [errors, setErrors] = useState({});\n  const [reportId, setReportId] = useState(null);\n  const [reportStatus, setReportStatus] = useState(\"idle\");\n  const [reportProgress, setReportProgress] = useState(0);\n  const [currentPhase, setCurrentPhase] = useState(0);\n  const [phaseDetails, setPhaseDetails] = useState([]);\n  const [reportResults, setReportResults] = useState(null);\n  const [currentPollInterval, setCurrentPollInterval] = useState(5000);\n  const [exportLoading, setExportLoading] = useState({\n    pdf: false,\n    sheets: false,\n    notion: false\n  });\n  const [exportError, setExportError] = useState(null);\n\n  // Constants\n  const initialPollInterval = 5000;\n  const maxPollInterval = 60000;\n  const pollTimeoutRef = useRef(null);\n\n  // Define phases\n  const phases = [{\n    id: 1,\n    name: \"Business Intelligence\",\n    description: \"Analyzing company data and market position\"\n  }, {\n    id: 2,\n    name: \"SEO & Social Intelligence\",\n    description: \"Researching keywords and competitive landscape\"\n  }, {\n    id: 3,\n    name: \"Strategic Synthesis\",\n    description: \"Combining insights for strategic recommendations\"\n  }, {\n    id: 4,\n    name: \"Golden Hippo Offer\",\n    description: \"Developing tiered pricing and value stacks\"\n  }, {\n    id: 5,\n    name: \"Convergence Blender\",\n    description: \"Creating 12-week content calendar\"\n  }, {\n    id: 6,\n    name: \"Master Content Bible\",\n    description: \"Finalizing implementation roadmap\"\n  }];\n\n  // Poll for report status updates - FIXED VERSION WITH PROPER PARENTHESES\n  const pollReportStatus = async (id, currentInterval) => {\n    try {\n      const response = await axios.get(`/cia/reports/${id}/status`);\n      const {\n        status,\n        progress,\n        currentPhase: newPhaseNumber,\n        phaseProgress,\n        errors: reportErrors\n      } = response.data;\n      setReportStatus(status);\n      setReportProgress(progress);\n      if (newPhaseNumber) {\n        setCurrentPhase(newPhaseNumber);\n        updatePhaseDetails(newPhaseNumber, phaseProgress, status);\n      }\n      if (status === \"completed\" || status === \"failed\") {\n        if (status === \"completed\") {\n          fetchReportResults(id);\n        } else if (status === \"failed\" && reportErrors && reportErrors.length > 0) {\n          setErrors(prevErrors => ({\n            ...prevErrors,\n            report: reportErrors.map(err => `${err.stage}: ${err.message}`).join(\", \")\n          }));\n        }\n        if (pollTimeoutRef.current) {\n          clearTimeout(pollTimeoutRef.current);\n        }\n        return;\n      }\n\n      // If still processing, schedule next poll with exponential backoff\n      const nextInterval = Math.min(currentInterval * 2, maxPollInterval);\n      setCurrentPollInterval(nextInterval);\n      pollTimeoutRef.current = setTimeout(() => pollReportStatus(id, nextInterval), nextInterval);\n    } catch (error) {\n      console.error(\"Error polling report status:\", error);\n      let nextInterval = currentInterval;\n      if (error.response && error.response.status === 429) {\n        console.warn(\"Rate limited. Increasing poll interval significantly.\");\n        nextInterval = maxPollInterval;\n      } else {\n        nextInterval = Math.min(currentInterval * 2, maxPollInterval);\n      }\n      setCurrentPollInterval(nextInterval);\n      if (reportStatus !== \"completed\" && reportStatus !== \"failed\") {\n        pollTimeoutRef.current = setTimeout(() => pollReportStatus(id, nextInterval), nextInterval);\n      }\n    }\n  };\n\n  // Add minimal implementations of other functions\n  // Function to update phaseDetails based on API response\n  const updatePhaseDetails = (newPhaseNumber, phaseProgressFromServer, currentStatus) => {\n    setPhaseDetails(prevDetails => {\n      let newPhaseDetails = [...prevDetails];\n\n      // Initialize array if empty\n      if (newPhaseDetails.length === 0) {\n        newPhaseDetails = phases.map(p => ({\n          id: p.id,\n          name: p.name,\n          progress: 0,\n          status: \"pending\"\n        }));\n      }\n\n      // If report is fully completed, mark every phase complete\n      if (currentStatus === \"completed\") {\n        return newPhaseDetails.map(phase => ({\n          ...phase,\n          progress: 100,\n          status: \"completed\"\n        }));\n      }\n\n      // Mark previous phases as completed\n      for (let i = 0; i < newPhaseNumber - 1; i++) {\n        if (newPhaseDetails[i]) {\n          newPhaseDetails[i] = {\n            ...newPhaseDetails[i],\n            progress: 100,\n            status: \"completed\"\n          };\n        }\n      }\n\n      // Update the current phase entry\n      if (newPhaseNumber > 0 && newPhaseNumber <= phases.length) {\n        const currentPhaseIndex = newPhaseNumber - 1;\n        newPhaseDetails[currentPhaseIndex] = {\n          ...newPhaseDetails[currentPhaseIndex],\n          progress: phaseProgressFromServer !== null && phaseProgressFromServer !== void 0 ? phaseProgressFromServer : 0,\n          status: phaseProgressFromServer >= 100 ? \"completed\" : \"processing\"\n        };\n      }\n\n      // Handle failure status\n      if (currentStatus === \"failed\" && newPhaseNumber > 0) {\n        const failingPhaseIndex = newPhaseNumber - 1;\n        // Mark active phase as failed if incomplete\n        if (newPhaseDetails[failingPhaseIndex] && newPhaseDetails[failingPhaseIndex].status !== \"completed\") {\n          newPhaseDetails[failingPhaseIndex].status = \"failed\";\n        }\n        // Reset subsequent phases to pending\n        for (let i = newPhaseNumber; i < phases.length; i++) {\n          if (newPhaseDetails[i]) {\n            newPhaseDetails[i].status = \"pending\";\n            newPhaseDetails[i].progress = 0;\n          }\n        }\n      }\n      return newPhaseDetails;\n    });\n  };\n\n  // Fetch report results\n  const fetchReportResults = async id => {\n    try {\n      const response = await axios.get(`/cia/reports/${id}`);\n      setReportResults(response.data);\n    } catch (error) {\n      console.error(\"Error fetching report results:\", error);\n      setErrors(prev => ({\n        ...prev,\n        results: \"Failed to fetch report results. Please try refreshing the page.\"\n      }));\n    }\n  };\n\n  // Check if all phases are complete\n  const areAllPhasesComplete = () => {\n    if (phaseDetails.length !== phases.length) return false;\n    return phaseDetails.every(phase => phase.status === \"completed\" && phase.progress === 100);\n  };\n\n  // Effect to handle polling\n  useEffect(() => {\n    if (reportId && reportStatus === \"processing\") {\n      if (pollTimeoutRef.current) {\n        clearTimeout(pollTimeoutRef.current);\n      }\n      setCurrentPollInterval(initialPollInterval);\n      pollTimeoutRef.current = setTimeout(() => pollReportStatus(reportId, initialPollInterval), initialPollInterval);\n    }\n    return () => {\n      if (pollTimeoutRef.current) {\n        clearTimeout(pollTimeoutRef.current);\n      }\n    };\n  }, [reportId, reportStatus]);\n\n  // Minimal rendering for testing\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"CIA Wizard\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 215,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"Test implementation with fixed axios call syntax\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 216,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 214,\n    columnNumber: 5\n  }, this);\n};\n_s(CIAWizard, \"fDyDsjKkCbFJUY6AnVgfMHQoXdk=\");\n_c = CIAWizard;\nexport default CIAWizard;\nvar _c;\n$RefreshReg$(_c, \"CIAWizard\");","map":{"version":3,"names":["React","useState","useEffect","useRef","axios","jsxDEV","_jsxDEV","CIAWizard","_s","formData","setFormData","companyName","websiteUrl","keyPersonOfInfluence","primaryKeyword","isSubmitting","setIsSubmitting","isSubmitted","setIsSubmitted","errors","setErrors","reportId","setReportId","reportStatus","setReportStatus","reportProgress","setReportProgress","currentPhase","setCurrentPhase","phaseDetails","setPhaseDetails","reportResults","setReportResults","currentPollInterval","setCurrentPollInterval","exportLoading","setExportLoading","pdf","sheets","notion","exportError","setExportError","initialPollInterval","maxPollInterval","pollTimeoutRef","phases","id","name","description","pollReportStatus","currentInterval","response","get","status","progress","newPhaseNumber","phaseProgress","reportErrors","data","updatePhaseDetails","fetchReportResults","length","prevErrors","report","map","err","stage","message","join","current","clearTimeout","nextInterval","Math","min","setTimeout","error","console","warn","phaseProgressFromServer","currentStatus","prevDetails","newPhaseDetails","p","phase","i","currentPhaseIndex","failingPhaseIndex","prev","results","areAllPhasesComplete","every","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/rodericandrews/Factory-ai/waterfall-app/client/src/components/CIA/CIAWizard.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport axios from \"../../utils/axios\";\n// Import other dependencies\n\nconst CIAWizard = () => {\n  // State declarations\n  const [formData, setFormData] = useState({\n    companyName: \"\",\n    websiteUrl: \"\",\n    keyPersonOfInfluence: \"\",\n    primaryKeyword: \"\"\n  });\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSubmitted, setIsSubmitted] = useState(false);\n  const [errors, setErrors] = useState({});\n  const [reportId, setReportId] = useState(null);\n  const [reportStatus, setReportStatus] = useState(\"idle\");\n  const [reportProgress, setReportProgress] = useState(0);\n  const [currentPhase, setCurrentPhase] = useState(0);\n  const [phaseDetails, setPhaseDetails] = useState([]);\n  const [reportResults, setReportResults] = useState(null);\n  const [currentPollInterval, setCurrentPollInterval] = useState(5000);\n  const [exportLoading, setExportLoading] = useState({\n    pdf: false,\n    sheets: false,\n    notion: false\n  });\n  const [exportError, setExportError] = useState(null);\n\n  // Constants\n  const initialPollInterval = 5000;\n  const maxPollInterval = 60000;\n  const pollTimeoutRef = useRef(null);\n\n  // Define phases\n  const phases = [\n    { id: 1, name: \"Business Intelligence\", description: \"Analyzing company data and market position\" },\n    { id: 2, name: \"SEO & Social Intelligence\", description: \"Researching keywords and competitive landscape\" },\n    { id: 3, name: \"Strategic Synthesis\", description: \"Combining insights for strategic recommendations\" },\n    { id: 4, name: \"Golden Hippo Offer\", description: \"Developing tiered pricing and value stacks\" },\n    { id: 5, name: \"Convergence Blender\", description: \"Creating 12-week content calendar\" },\n    { id: 6, name: \"Master Content Bible\", description: \"Finalizing implementation roadmap\" }\n  ];\n\n  // Poll for report status updates - FIXED VERSION WITH PROPER PARENTHESES\n  const pollReportStatus = async (id, currentInterval) => {\n    try {\n      const response = await axios.get(`/cia/reports/${id}/status`);\n      const { status, progress, currentPhase: newPhaseNumber, phaseProgress, errors: reportErrors } = response.data;\n\n      setReportStatus(status);\n      setReportProgress(progress);\n\n      if (newPhaseNumber) {\n        setCurrentPhase(newPhaseNumber);\n        updatePhaseDetails(newPhaseNumber, phaseProgress, status);\n      }\n\n      if (status === \"completed\" || status === \"failed\") {\n        if (status === \"completed\") {\n          fetchReportResults(id);\n        } else if (status === \"failed\" && reportErrors && reportErrors.length > 0) {\n          setErrors(prevErrors => ({\n            ...prevErrors,\n            report: reportErrors.map(err => `${err.stage}: ${err.message}`).join(\", \")\n          }));\n        }\n        if (pollTimeoutRef.current) {\n          clearTimeout(pollTimeoutRef.current);\n        }\n        return;\n      }\n\n      // If still processing, schedule next poll with exponential backoff\n      const nextInterval = Math.min(currentInterval * 2, maxPollInterval);\n      setCurrentPollInterval(nextInterval);\n      pollTimeoutRef.current = setTimeout(() => pollReportStatus(id, nextInterval), nextInterval);\n\n    } catch (error) {\n      console.error(\"Error polling report status:\", error);\n      let nextInterval = currentInterval;\n      \n      if (error.response && error.response.status === 429) {\n        console.warn(\"Rate limited. Increasing poll interval significantly.\");\n        nextInterval = maxPollInterval;\n      } else {\n        nextInterval = Math.min(currentInterval * 2, maxPollInterval);\n      }\n      \n      setCurrentPollInterval(nextInterval);\n      \n      if (reportStatus !== \"completed\" && reportStatus !== \"failed\") {\n        pollTimeoutRef.current = setTimeout(() => pollReportStatus(id, nextInterval), nextInterval);\n      }\n    }\n  };\n\n  // Add minimal implementations of other functions\n  // Function to update phaseDetails based on API response\n  const updatePhaseDetails = (\n    newPhaseNumber,\n    phaseProgressFromServer,\n    currentStatus\n  ) => {\n    setPhaseDetails(prevDetails => {\n      let newPhaseDetails = [...prevDetails];\n\n      // Initialize array if empty\n      if (newPhaseDetails.length === 0) {\n        newPhaseDetails = phases.map(p => ({\n          id: p.id,\n          name: p.name,\n          progress: 0,\n          status: \"pending\"\n        }));\n      }\n\n      // If report is fully completed, mark every phase complete\n      if (currentStatus === \"completed\") {\n        return newPhaseDetails.map(phase => ({\n          ...phase,\n          progress: 100,\n          status: \"completed\"\n        }));\n      }\n\n      // Mark previous phases as completed\n      for (let i = 0; i < newPhaseNumber - 1; i++) {\n        if (newPhaseDetails[i]) {\n          newPhaseDetails[i] = {\n            ...newPhaseDetails[i],\n            progress: 100,\n            status: \"completed\"\n          };\n        }\n      }\n\n      // Update the current phase entry\n      if (newPhaseNumber > 0 && newPhaseNumber <= phases.length) {\n        const currentPhaseIndex = newPhaseNumber - 1;\n        newPhaseDetails[currentPhaseIndex] = {\n          ...newPhaseDetails[currentPhaseIndex],\n          progress: phaseProgressFromServer ?? 0,\n          status:\n            phaseProgressFromServer >= 100 ? \"completed\" : \"processing\"\n        };\n      }\n\n      // Handle failure status\n      if (currentStatus === \"failed\" && newPhaseNumber > 0) {\n        const failingPhaseIndex = newPhaseNumber - 1;\n        // Mark active phase as failed if incomplete\n        if (\n          newPhaseDetails[failingPhaseIndex] &&\n          newPhaseDetails[failingPhaseIndex].status !== \"completed\"\n        ) {\n          newPhaseDetails[failingPhaseIndex].status = \"failed\";\n        }\n        // Reset subsequent phases to pending\n        for (let i = newPhaseNumber; i < phases.length; i++) {\n          if (newPhaseDetails[i]) {\n            newPhaseDetails[i].status = \"pending\";\n            newPhaseDetails[i].progress = 0;\n          }\n        }\n      }\n\n      return newPhaseDetails;\n    });\n  };\n\n  // Fetch report results\n  const fetchReportResults = async id => {\n    try {\n      const response = await axios.get(`/cia/reports/${id}`);\n      setReportResults(response.data);\n    } catch (error) {\n      console.error(\"Error fetching report results:\", error);\n      setErrors(prev => ({\n        ...prev,\n        results:\n          \"Failed to fetch report results. Please try refreshing the page.\"\n      }));\n    }\n  };\n\n  // Check if all phases are complete\n  const areAllPhasesComplete = () => {\n    if (phaseDetails.length !== phases.length) return false;\n    return phaseDetails.every(\n      phase => phase.status === \"completed\" && phase.progress === 100\n    );\n  };\n\n  // Effect to handle polling\n  useEffect(() => {\n    if (reportId && reportStatus === \"processing\") {\n      if (pollTimeoutRef.current) {\n        clearTimeout(pollTimeoutRef.current);\n      }\n      setCurrentPollInterval(initialPollInterval);\n      pollTimeoutRef.current = setTimeout(() => pollReportStatus(reportId, initialPollInterval), initialPollInterval);\n    }\n    \n    return () => {\n      if (pollTimeoutRef.current) {\n        clearTimeout(pollTimeoutRef.current);\n      }\n    };\n  }, [reportId, reportStatus]);\n\n  // Minimal rendering for testing\n  return (\n    <div>\n      <h1>CIA Wizard</h1>\n      <p>Test implementation with fixed axios call syntax</p>\n    </div>\n  );\n};\n\nexport default CIAWizard;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}